# QUIC의 동작방식

## QUIC의 동작 방식

이번 장에서는 QUIC 전송 프로토콜의 기본적인 구성 요소가 어떻게 동작하는지를 설명한다. QUIC 스택을 직접 구현하고자 한다면 이 책의 설명을 통해 전반적인 내용을 이해할 수는 있지만, 세부 내용은 IETF의 인터넷 드래프트와 RFC를 참고하기 바란다.

1. [연결](https://github.com/bagder/http3-explained/blob/master/ko/quic-connections.md)을 설정한다.
2. 여기에는 [TLS 보안](https://github.com/bagder/http3-explained/blob/master/ko/quic-tls.md)이 포함되어 있다.
3. [스트림](https://github.com/bagder/http3-explained/blob/master/ko/quic-streams.md)을 사용한다.



## 연결

QUIC 연결은 두 QUIC 엔드포인트 사이의 대화이다. QUIC의 연결 설정은 버전 협상, 암호화, 전송 핸드쉐이크로 구성되어 있으므로 연결 설정의 지연시간을 줄여준다.

이러한 연결을 통해 실제 데이터를 보내려면 하나 이상의 스트림을 만들어서 사용해야 한다.

### 연결 ID

각 연결은 연결 식별자나 연결 ID를 가지므로 이를 통해 연결을 식별한다. 엔드포인트가 자유롭게 연결 ID를 선택한다. 각 엔드포인트는 엔드포인트의 피어가 사용할 연결 ID를 선택한다.

이 연결 ID의 주요 기능은 하위 프로토콜 계층\(UDP, IP 혹은 그 아래 계층\)에서 주소가 변경되더라도 QUIC 연결의 패킷이 잘못된 엔드포인트로 전달되지 않도록 보장하는 것이다.

연결 ID를 이용하면 TCP에서는 불가능했던 방법으로 IP 주소와 네트워크 인터페이스 사이에서 연결을 마이그레이션 할 수 있다. 예를 들면 사용자가 자신의 기기를 들고 wifi가 지원되는 곳으로 이동했을 때 다운로드를 진행하면서 셀룰러 네트워크 연결에서 더 빠른 wifi 연결로 변경되는 것이 이 마이그레이션을 통해 가능하다. 마찬가지로 wifi를 이용할 수 없게 되었을 때 셀룰러 연결을 통해 다운로드를 진행할 수 있다.

### 포트 번호

QUIC이 UDP 위에 만들어졌으므로 들어오는 연결을 구분하기 위해 16비트 포트 번호 필드를 사용한다.

### 버전 협상

클라이언트는 QUIC 연결 요청에서 어떤 QUIC 프로토콜 버전으로 통신하고 싶은지 서버에게 알려주고 서버는 클라이언트가 선택할 수 있도록 지원하는 버전 목록을 응답한다.

  


## TLS을 사용하는 연결

초기 패킷이 연결을 설정하자마자 초기화하는 쪽에서 보안 계층 핸드쉐이크의 설정을 시작하는 암호화 프레임을 보낸다. 보안 계층은 TLS 1.3 보안을 사용한다.

QUIC 연결에서에는 반드시 TLS를 사용해야 한다. QUIC 프로토콜은 프로토콜 고착화를 방지하기 위해 미들박스가 조작하기 어렵게 설계되었다.

  


## 스트림

QUIC 스트림은 경량이면서 순서가 있는 바이트 스트림 추상화를 제공한다.

QUIC에는 두가지 기본 스트림 타입이 있다.

* 단방향 스트림은 한쪽으로 데이터를 전달한다. 즉, 스트림을 시작한 쪽에서 피어로 전달된다.
* 양방향 스트림은 양쪽으로 데이터를 보낼 수 있다.

두 엔드포인트가 두 타입의 스트림을 모두 만들 수 있고 스트림은 다른 스트림과 상호배치된 데이터를 동시에 보낼 수 있고 취소할 수도 있다.

QUIC 연결을 통해 데이터를 보낼 때 하나 이상의 스트림을 사용한다.

### 흐름 제어

스트림은 개별적으로 흐름 제어가 되므로 엔드포인트가 메모리 사용을 제한할 수 있고 백프레셔\(back pressure\)를 적용할 수도 있다. 스트림의 생성도 흐름 제어가 되고 각 피어는 일정 시간 동안 받고자 하는 최대 스트림 ID를 정의할 수 있다.

### 스트림 식별자

스트림 ID라고 부르는 부호없는 62비트 정수로 스트림을 식별한다. 스트림 ID의 최하위 2비트를 스트림\(단방향이나 양방향이나\)의 타입과 스트림을 시작한 쪽을 식별하는 데 사용한다.

스트림 ID의 최하위 비트\(0x1\)는 누가 스트림을 시작했는지를 식별한다. 클라이언트는 짝수의 스트림\(최하위 비트가 0으로 설정된 스트림\)을 초기화 하고 서버는 홀수의 스트림\(최하위 비트가 1으로 설정된 스트림\)을 초기화한다.

스트림 ID의 두 번째 하위 비트\(0x2\)는 단방향 스트림과 양방향 스트림을 구분한다. 단방향 스트림을 항상 이 비트를 1로 설정하고 양방향 스트림은 이 비트를 0으로 설정한다.

### 스트림 동시성

QUIC에서는 임의의 스트림이 다수 동시에 동작할 수 있다. 엔드포인드는 최대 스트림 ID를 제한해서 동시에 받아들이는 활성 스트림의 수를 제한한다.

엔드포인트마다 최대 스트림 ID를 설정하고 설정을 받는 피어에만 적용된다.

### 데이터 보내기와 받기

엔드포인트는 스트림을 사용해서 데이터를 보내고 받고 이는 스트림의 원래 목적이다. 스트림은 순서가 맞는 바이트 스트림 추상화다. 하지만 별도의 스트림은 원래 순서대로 전달되지 않는다.

### 스트림의 우선순위

스트림에 할당된 리소스의 우선순위가 제대로 설정되면 스트림 멀티플렉싱은 애플리케이션 성능에 상당한 영향을 준다. HTTP/2 같은 멀티플렉싱을 지원하는 다른 프로토콜의 경험에서 상당히 긍적적인 성능 효과를 보여주는 효율적인 우선순위 전략을 볼 수 있다.

QUIC 자체에서 우선순위를 결정하는 정보를 교환하는 프레임을 제공하지는 않는다. 대신 QUIC을 사용하는 애플리케이션에서 우선순위 정보를 받는데 의존한다. QUIC을 사용하는 프로토콜은 애플리케이션의 의미에 적합한 우선순위 스키마를 정의할 수 있다.

QUIC을 통해 HTTP/3을 사용할 때 우선순위는 HTTP 계층에서 동작한다.

### 0-RTT 

새로운 연결을 설정하는데 필요한 시간을 줄이려고 이전에 서버에 연결했던 클라이언트는 해당 연결의 특정 파라미터를 캐시한 뒤 이어서 서버와 **0-RTT** 연결을 설정할 수 있다. 이로 인해서 클라이언트는 핸드쉐이크가 완료되기를 기다리지 않고 바로 데이터를 보낼 수 있다.

### 스핀 비트\(Spin Bit\)

QUIC 워킹그룹에서 수백 개의 이메일을 주고받고 수십 시간의 토론을 걸친 가장 긴 설계 토론 중 하나가 단일 비트 즉, 스핀 비트\(Spin Bit\)에 관한 것이다.

이 스핀 비트를 지지하는 사람들은 두 QUIC 엔드포인트 사이에 있는 운영자나 사람들이 지연 시간을 측정할 필요가 있다고 주장한다.

이 기능을 반대하는 사람들은 잠재적인 정보 유출을 좋아하지 않았다.

### 비트 회전시키기

클라이언트와 서버 두 엔드포인트는 각 QUIC 연결에 대해 0 또는 1의 스핀 값을 유지하면서 해당 연결에 적절한 값으로 스핀 비트를 설정해서 패킷을 보낸다.

양 측은 한 라운드 트립동안 같은 값으로 설정된 스핀 비트를 가진 패킷을 보내고 이후 이 값을 토글한다. 이로 인해 비트 필드에 0과 1의 파동이 나타나고 관찰자가 이를 모니터링할 수 있다.

발송자가 애플리케이션도 아니고 제약된 흐름 제어도 아닌 경우에만 이 측정을 할 수 있고 네트워크에서 패킷의 순서가 재정리될 때도 데이터에 잡음이 낄 수 있다.  


### 사용자 영역

사용자 영역에서 전송 프로토콜을 구현하면 클라이언트와 서버가 새로운 버전을 배포하기 위해 운영체제 커널을 업데이트할 필요가 없어서 비교적 쉽게 프로토콜을 발전시킬 수 있으므로 프로토콜을 빠르게 반복할 수 있다.

미래에 운영체제 커널에서 구현되거나 제공하지 않도록 막는 것은 QUIC에 아무것도 없으므로 누군가 좋은 방법을 찾아야 한다.

#### 많은 구현체

사용자 영역에서 새로운 전송 프로토콜을 구현하는 한 가지 명백한 효과는 다수의 독립적인 구현체를 볼 수 있다는 것이다.

예견할 수 있는 미래에 다른 애플리케이션은 다른 HTTP/3와 QUIC 구현체를 포함할\(또는 계층 위에서\) 것이다.

### API

TCP와 TCP를 사용하는 프로그램의 성공 요소 중 하나는 표준화된 소켓 API이다. 소켓 API는 기능이 잘 정의되어 있고 이 API를 사용하면 TCP가 똑같이 동작하므로 다수의 다른 운영체제 사이에서 프로그램을 이동시킬 수 있다.

QUIC은 그렇지 않다. QUIC에는 표준 API가 없다.

QUIC에서는 기존 라이브러리 구현체 중 하나를 선택하고 그 API를 따라야 한다. 이는 애플리케이션을 어떤 부분에서 하나의 라이브러리에 "락인\(locked in\)"시킨다. 다른 라이브러리로 바꾼다는 것은 다른 API를 뜻하므로 많은 작업이 필요할 것이다.

또한 QUIC이 보통 사용자 영역에서 구현되므로 소켓 API를 쉽게 확장할 수 없고 기존의 TCP나 UDP 기능과 비슷하게 보일 수 없다. QUIC을 사용한다는 것은 소켓 API와는 다른 API를 사용한다는 것을 의미한다.


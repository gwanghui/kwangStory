# 과정



Google의 Jim Roskind가 초기 QUIC 프로토콜을 설계하고 2012년 처음 구현했으며 Google의 실험을 확대한 2013년 전 세계에 공개적으로 발표했다.

그 당시에는 QUIC이 "Quick UDP Internet Connections"의 약자라고 주장했었지만, 이후에는 없어졌다.

Google이 프로토콜을 구현하고 이어서 널리 사용되는 자신들의 브라우저\(Chrome\)와 서버사이드 서비스\(Google 검색, gmail, youtube 등\)에 배포했다. Google은 프로토콜 버전을 꽤 빠르게 올리면서 이 개념이 시간이 지남에 따라 엄청난 수의 사용자에게 신뢰할 수 있게 동작한다는 것을 증명했다.

2015년 6월 표준화를 위해 QUIC의 첫 번째 인터넷 드래프트 버전을 IETF에 제출했지만 2016년 후반이 되어서야 QUIC 워킹 그룹이 승인되어 시작되었다. 하지만 이후 바로 많은 단체의 엄청난 관심을 받으면서 시작되었다.

2017년 Google의 QUIC 엔지니어가 인용한 수치에 따르면 _전체_ 인터넷 통신량의 약 7%가 이미 QUIC을 사용한다고 한다. 이는 QUIC 프로토콜의 Google 버전이다.



### IETF

IETF에서 프로토콜을 표준화하려고 만든 QUIC 워킹 그룹은 QUIC 프로토콜이 "단순히" HTTP가 아닌 다른 프로토콜을 전송할 수 있어야 한다고 빠르게 결정했다. Google-QUIC은 오로지 HTTP만 전송했고 실제로 HTTP/2 프레임 문법을 사용해서 HTTP/2 프레임을 효과적으로 전송했다.

IETF-QUIC은 Google-QUIC이 사용한 "커스텀" 접근 방법이 아니라 TLS 1.3의 암호화와 보안을 기반으로 두어야 한다고도 발표했다.

HTTP보다 더 많이 보내야 한다는 요구를 만족시키기 위해 IETF QUIC 프로토콜 아키텍처를 두 가지 별도의 계층인 전송 QUIC과 "HTTP over QUIC" 계층\(후자는 종종 "hq"라고도 한다\)으로 분할했다.

무해할 것처럼 들렸던 이 계층 분할로 인해 IETF-QUIC은 원래의 Google-QUIC과 많이 달라졌다.

하지만 워킹 그룹은 곧 적절하게 집중해서 제때 QUIC 버전 1을 제공할 수 있도록 HTTP를 제공하는 데 집중하고 HTTP가 아닌 전송은 나중 작업으로 남겨두기로 했다.

2018년 3월 이 책의 작업을 시작할 때 QUIC 버전 1의 최종 명세를 2018년 11월에 발표 할 계획이었다. 이는 나중에 2019년 7월로 연기되었다.

IETF-QUIC 작업이 진행되는 동안 Google 팀은 IETF 버전의 세부 내용을 받아들였고 IETF 버전이 만들어질 방향으로 Google 버전의 프로토콜을 천천히 발전시켰다. Google은 자사의 브라우저와 서비스에서 QUIC의 Google 버전을 계속해서 사용하고 있다.

[개발 중인 대부분의 새로운 구현](https://github.com/quicwg/base-drafts/wiki/Implementations)은 IETF 버전에 집중하고 Google 버전과는 호환되지 않는다.

### HTTP/2에서의 경험

HTTP/2 명세 RFC 7540는 2015년 5월 발행되었는데 이는 QUIC이 처음으로 IETF에 들어오기 바로 한 달 전이다.

HTTP/2에서 유선으로 HTTP를 통한 HTTP를 변경할 기반이 마련되었고 HTTP/2를 만든 워킹그룹이 버전 1에서 버전 2로 가는 것보다 새로운 HTTP 버전으로 가는 걸 돕는 것이 훨씬 빠르다고 생각하게 되었다.\(약 16년\)

HTTP/2를 겪으면서 사용자와 소프트웨어 스택은 HTTP는 더는 텍스트 기반 프로토콜이라고만 가정할 수 없다고 생각하게 되었다.

HTTP-over-QUIC은 2018년 11월에 HTTP/3로 개명되었다.  




## 상태

QUIC 워킹 그룹은 2016년 후반부터 프로토콜을 제정하는 일에 열심히 노력했고 현재 계획은 2019년 7월에 완료하는 것이다.

2018년 11월까지도 HTTP/3의 아직 대규모 연동 테스트를 진행하지 않았다. 기존에 두 개의 구현체가 있는데 둘 다 브라우저나 인기있는 공개 서버 소프트웨어와의 테스트를 하지 않았다.

QUIC 워킹 그룹의 위키 페이지에 나열된 15개 정도의 서로 다른 [QUIC 구현체](https://github.com/curl/curl/wiki/QUIC-implementation)가 있지만 이들 모두 최신 명세 드래프트 개정판과 연동되지 않는다.

QUIC을 구현하는 것은 쉽지 않고 프로토콜은 오늘날 까지도 계속 진화하며 변하고 있다.

### 서버

지금까지 Apache나 nginx에서 공개적으로 QUIC을 지원한다는 발표는 없다.

### 클라이언트

아직 대형 브라우저 벤더중 아무도 QUIC이나 HTTP/3의 IETF 버전을 실행할 수 있는 버전을 제공하거나 발표하지 않았다.

수년간 Google Chrome은 Google 자체의 QUIC 버전의 구현체를 포함해서 배포했지만 이는 IETF QUIC 프로토콜과 연동되지 않고 그 HTTP 구현체는 HTTP/3와도 다르다.

### 구현 방해물

QUIC은 뭔가 새로운 것을 발명하지 않고 신뢰할 수 있는 기존 프로토콜을 사용하고자 TLS 1.3을 암호화와 보안 계층의 기반으로 사용하기로 했다. 하지만 이 작업을 하면서 워킹 그룹은 QUIC에서 TLS의 사용을 실제로 간소화하기로 발표했다. 즉, 프로토콜은 "TLS 레코드"는 사용하지 않고 "TLS 메시지"만 사용해야 한다.

이것이 무해한 변화처럼 들릴 수 있지만 수많은 QUIC 스택 구현자들에게는 커다란 걸림돌이 되었다. TLS 1.3을 지원하는 기존 TLS 라이브러리는 이 기능을 공개하거나 QUIC이 접근할 수 있는 API가 충분치 않다. 더 큰 조직에서 온 몇몇 QUIC 구현자들은 자신들의 TLS 스택에도 동시에 작업을 하고 있지만 모두가 그런 것은 아니다.

예시로 중량급 지배적 오픈 소스인 OpenSSL은 이에 대한 API가 전혀 없고 근래에 제공할 의사를 밝힌 적이 없다.\(2018년 11월 기준\)

이는 QUIC 스택이 다른 TLS 라이브러리\(별도로 수정한 OpenSSL 빌드\)를 사용하거나 향후 OpenSSL 버전을 수정할 필요가 있기 때문에 결국 배포 상의 걸림돌이다.

### 커널과 CPU 부하

Google과 Facebook은 QUIC의 대규모 배포가 TLS에서 HTTP/2로 서비스 할때보다 같은 트래픽 기준으로 거의 2배의 CPU가 필요하다고 얘기했다.

이는 다음과 같은 이유 때문이다.

* 본질적으로 Linux의 UDP 부분은 TCP 스택만큼 최적화되어 있지 않다. 이는 전통적으로 지금처럼 고속 전송에 사용해오지 않았기 때문이다.
* 하드웨어가 TCP와 TLS의 부담을 덜어주고 있지만 UDP에 대해서 그렇게 하는 경우는 드물고 기본적으로 QUIC에 대해서는 아예 존재하지 않는다.

시간이 지나면 성능 및 필요한 CPU가 개선될 것이라고 생각한다.




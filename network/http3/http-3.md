# HTTP/3

## HTTP/3

이전에 얘기했듯이 QUIC을 통해 전송하는 첫 주요 프로토콜은 HTTP다.

완전히 새로운 방법으로 유선을 통해 HTTP를 전송하려고 HTTP/2를 도입한 것처럼 HTTP/3는 다시 한번 네트워크를 통해 HTTP를 전송하는 새로운 방법을 도입한다.

HTTP는 여전히 이전과 같은 개념과 패러다임을 유지한다. 헤더와 보디가 있고 요청과 응답이 있고 동사, 쿠키, 캐시가 있다. 통신 상대측으로 비트를 보내는 방법이 HTTP/3에서 주된 변경점이다.

QUIC을 통해 HTTP를 보내기 위해 변경이 필요했고 그 결과물을 HTTP/3라고 부른다. QUIC이 제공하는 특성이 TCP의 특성과는 다르므로 변경이 필요했다. 변경사항은 다음과 같다.

* QUIC에서 전송 자체에서 스트림을 제공하지만 HTTP/2에서는 HTTP 계층에서 스트림이 제공된다.
* 스트림이 서로 독립적이므로 HTTP/2에서 사용된 헤더 압축 프로토콜을 head of line 블로킹 문제를 발생시키지 않으면서 사용할 수 없다.
* QUIC 스트림은 HTTP/2 스트림과는 다소 다르다. HTTP/3 부분에서 자세히 설명할 것이다.

### HTTPS:// URL 

최신 클라이언트와 서버는 아마도 첫 핸드쉐이크에서 HTTP/2를 협상할 것이다. 연결이 설정되고 클라이언트의 HTTP 요청에 서버가 응답할 때 서버는 HTTP/3의 지원과 선호도에 관해 클라이언트에게 알려줄 수 있다.

이전에 방문한 적이 없는 HTTPS:// URL에 대한 새로운 첫 연결은 아마도 TCP를 통해 수행될 것이다. \(추가로 QUIC을 통한 병렬연결 시도가 있을 수 있다.\) 호스트가 QUIC을 지원하지 않는 레거시 서버일 수도 있고 중간에 있는 미들박스가 QUIC 연결이 성공적으로 이뤄지지 않도록 하는 장애물일 수도 있다.

### 초기 연결

레거시, 평문, `HTTP://` URL은 지금 그대로 유지될 것이지만 더 안전한 전송을 하는 미래로 나아갈수록 점점 덜 사용될 것이다. 이러한 URL에 대한 요청은 HTTP/3를 사용하도록 업그레이드되지 않을 것이다. 현실에서 이러한 것들이 HTTP/2로 업그레이드하는 경우는 거의 없지만 다른 이유 때문이다.

하지만 HTTP/2가 유선으로 HTTP를 전송하는 완전히 새로운 방법이지만 HTTP/1이 그랬듯이 여전히 TLS와 TCP에 기반을 두고 있었기에 HTTP/3 상황에서 복잡성을 추가하게 되었다. HTTP/3가 QUIC을 통해 수행된다는 점은 몇 가지 중요한 관점에서 변경이 발생했다.

HTTP/3는 `HTTPS://` URL을 사용해서 실행될 것이다. 세상은 이러한 URL로 가득 차 있고 새로운 프로토콜에 또 다른 URL 스킴을 도입하는 것은 실용적이지도 않고 완전히 불합리하다고 여겨졌다. HTTP/2에 새로운 스킴이 필요 없었듯이 HTTP/3에도 필요 없다.

## Alt-svc

대체 서비스 헤더\(Alt-svc:\)와 이에 대응되는 `ALT-SVC` HTTP/2 프레임이 QUIC이나 HTTP/3를 위해 특별히 만들어진 것은 아니다. 서버가 클라이언트에게 \*"봐라. 이 포트에서 이 프로토콜로 이 호스트에서 같은 서비스를 운영하고 있다."\*라고 말할 수 있도록 이미 설계되고 만들어진 메커니즘의 일부이다. 자세한 내용은 [RFC 7838](https://tools.ietf.org/html/rfc7838)를 참고해라.

이러한 Alt-svc 응답을 받은 클라이언트는 \(이를 지원하고 원하는 경우\) 주어진 다른 호스트에 지정된 프로토콜로 백그라운드에서 병렬 연결을 하도록 권고받는다. 성공적으로 전환된다면 초기 연결 대신 새로운 연결을 통해서 해당 작업을 수행한다.

초기 연결이 HTTP/2나 HTTP/1을 사용하더라도 서버는 다시 연결해서 HTTP/3를 시도할 수 있다고 클라이언트에게 알려줄 수 있다. 이는 같은 호스트일 수도 있고 요청한 내용을 제공하는 방법을 아는 다른 호스트일 수도 있다. 이러한 Alt-svc 응답에서 제공된 정보에는 만료 타이머가 있어서, 클라이언트가 일정 시간 동안 제안받은 대체 프로토콜로 직접 대체 호스트에 이어진 연결과 요청을 할 수 있다.

### 예시

HTTP 서버는 응답에 `Alt-Svc:` 헤더를 다음과 같이 포함한다.

```text
Alt-Svc: h3=":50781"
```

이는 해당 응답을 얻는데 사용한 것과 같은 호스트 이름의 50781 UDP 포트에서 HTTP/3를 사용할 수 있음을 나타낸다.

그 다음 클라이언트는 해당 목적지에 QUIC 연결을 설정하려고 시도하고 연결이 성공하면 초기 HTTP 버전 대신 이러한 출처와 계속해서 통신한다.  


### QUIC 스트림과 HTTP/3

HTTP/2가 TCP를 기반으로 전체적인 스트림과 멀티플렉싱 개념을 설계해야했던 반면 HTTP/3는 QUIC을 위해 만들어졌으므로 QUIC 스트림이 가진 이점을 최대한 활용한다.

HTTP/3를 통해 수행되는 HTTP 요청은 특정 스트림 세트를 사용한다.

### HTTP/3 프레임

HTTP/3는 QUIC 스트림을 설정하고 반대쪽 끝으로 프레임 세트를 보내는 것을 의미한다. HTTP/3에는 몇 가지 알려진 프레임이 고정되어 있다. 이 중 가장 중요한 것은 다음과 같다.

* HEADERS, 압축된 HTTP 헤더를 보내라.
* DATA, 바이너리 데이터 콘텐츠를 보내라.
* GOAWAY, 이 연결을 종료해라.

### HTTP 요청

클라이언트는 클라이언트가 초기화한 _양방향_ QUIC 스트림으로 HTTP 요청을 보낸다.

단일 HEADERS 프레임으로 구성된 요청은 하나 또는 두 개의 다른 프레임, 즉 일련의 DATA 프레임과 뒤이어 오는 것들을 위한 최종 HEADERS 프레임이 따라올 수 있다.

요청을 보낸 후 클라이언트는 전송용 스트림을 닫는다.

### HTTP 응답

서버는 양방향 스트림으로 해당 HTTP 응답을 돌려보낸다. 여기에는 HEADERS 프레임과 일련의 DATA 프레임이 있고 뒤따라오는 HEADERS 프레임이 있을 수 있다.

### QPACK 헤더

HEADERS 프레임은 QPACK 알고리즘으로 압축된 HTTP 헤더를 담고 있다. QPACK은 HPACK이라고 부르는 HTTP/2의 압축과 형식 면에서 비슷하지만, 순서가 맞지 않게 전송된 스트림에서 동작하도록 수정되었다.

QPACK 자체는 두 엔드포인트 사이에서 추가적인 두 개의 단방향 QUIC 스트림을 사용한다. 이 스트림은 양방향으로 동적 테이블 정보를 전달하는 데 사용된다.

## HTTP/3 우선순위 정하기

HTTP/3 스트림 프레임 중에는 `PRIORITY`라는 프레임이 있다. 이 프레임은 HTTP/2에서 동작한 방식과 비슷하게 스트림의 우선순위와 의존성을 설정하는 데 사용한다.

이 프레임은 특정 스트림이 다른 스트림에 의존하도록 설정할 수 있고 해당 스트림에 "가중치"를 설정할 수 있다.

종속된 스트림은 의존하는 스트림이 모두 닫혔을 때만 리소스가 할당받아야 하고 아니면 진행될 수 없다.

스트림 가중치는 1부터 256 사이의 값을 가지며 같은 부모를 가진 스트림은 **반드시** 가중치에 따라 리소스를 할당받아야 한다.

### HTTP/3 서버 푸시 

라운드 트립의 절반을 줄일 수 있지만, 여전히 대역폭을 사용하기 때문에 푸시는 결코 "공짜"가 아니다. 실제로 리소스가 푸시되어야 하는지 아닌지를 서버 측에서 확실하게 알기가 어렵거나 불가능하다.

이 기능은 HTTP/2 개발에서 처음 논의된 이후 HTTP/2 프로토콜이 나오고 인터넷에 배포된 뒤, 이 기능을 유용하게 만들기 위해 셀 수 없이 다양한 방법으로 논의되고, 싫어하게 했으며, 두들겨 맞았다.

### 문제점

클라이언트가 미리 푸시를 받을 수 있다고 말했더라도, 클라이언트가 적합하다고 판단하면 푸시된 개별 스트림을 언제든 취소할 수 있다. 그리고 서버에 `CANCEL_PUSH` 프레임을 보낸다.

클라이언트가 요청하지는 않았지만 어쨌든 서버가 받아야 하는 추가 리소스가 있다고 판단하면, \(요청 스트림을 통해\) 서버가 요청에 푸시로 응답한 것처럼 보이는 `PUSH_PROMISE` 프레임을 보낼 수 있다. 그다음 실제 응답은 새로운 스트림을 통해 보낸다.

서버 푸시는 클라이언트 쪽에서 서버 푸시에 동의했을 때만 발생할 수 있다. HTTP/3에서는 클라이언트가 최대 푸시 스트림의 ID가 무엇인지 서버에게 알려주어 클라이언트가 얼마나 많은 푸시를 받을지를 제한한다. 이 제한을 초과하면 연결 오류가 발생할 것이다.

서버 푸시는 클라이언트가 보낸 적이 없는 요청에 대한 효율적인 응답이다!

HTTP/3 서버 푸시는 HTTP/2에서 설명된 내용\([RFC 7540](https://httpwg.org/specs/rfc7540.html)\)과 비슷하지만 다른 메커니즘을 사용한다.

## HTTP/3과 HTTP/2의 비교

HTTP/3는 자체적으로 스트림을 다루는 전송 프로토콜인 QUIC을 위해 설계되었다.

HTTP/2는 TCP를 위해 설계되었으므로 HTTP 계층에서 스트림을 다룬다.

### 유사점

이 두 프로토콜을 사실상 같은 기능을 제공한다.

* 두 프로토콜은 스트림을 제공한다.
* 두 프로토콜은 서버 푸시를 지원한다
* 두 프로토콜은 헤더 압축을 제공한다. QPACK과 HPACK은 설계상 비슷하다.
* 두 프로토콜은 스트림을 이용해서 하나의 연결을 통해 멀티플랙싱을 제공한다.
* 두 프로토콜은 스트림에 우선순위를 정한다.

### 차이점

세부 내용에 차이점이 있는데 주로 HTTP/3의 QUIC 사용 때문에 생긴다.

* QUIC의 0-RTT 핸드쉐이크 덕에 HTTP/3에서는 이른 데이터 지원이 더 낫게 잘 동작한다. TCP Fast Open과 TLS는 더 적은 데이터를 보내지만, 종종 문제점에 직면한다.
* HTTP/3는 QUIC 덕에 TCP + TLS보다 훨씬 더 빠른 핸드쉐이크를 제공한다.
* HTTP/3에는 안전하지 않거나 암호화되지 않은 버전이 없다. 인터넷에서 드물기는 하지만 HTTP/2는 HTTPS 없이 구현하고 사용할 수 있다.
* HTTP/2가 ALPN 확장을 이용하여 즉시 TLS 핸드쉐이크 협상을 완료할 수 있는 반면 HTTP/3는 QUIC을 사용하므로 클라이언트에 이 사실을 알리기 위해 `Alt-Svc:` 헤더 응답이 먼저 있어야 한다.



  


  



# 프로토콜 기능

## 프로토콜 기능

고수준에서 QUIC 프로토콜을 보자.

아래 그림은 HTTP를 전송할 때 HTTP/2 네트워크 스택을 왼쪽에 QUIC 네트워크 스택을 오른쪽에 보여준다.

[![QUIC &#xC2A4;&#xD0DD;](https://github.com/bagder/http3-explained/raw/master/images/quic-stack.png)](https://github.com/bagder/http3-explained/blob/master/images/quic-stack.png)

### UDP 상의 전송 프로토콜

QUIC이 인터넷 세상에 가치를 더할 수 있다고 증명한다면 사람들은 사용하기를 원할 것이고 그들의 네트워크에서 동작하길 원할 것이다. 그러면 회사들은 자신들의 장애물을 재고하기 시작할 것이다. 수년간 QUIC 개발은 진척이 있었으며, 인터넷에서 QUIC 연결을 설정하고 사용하는 성공률이 증가하고 있다.

### 나아질 것인가?

가까운 미래에 QUIC 기반의 모든 전송은 아마도 그레이스풀하게 \(TCP 기반의\) 다른 대안 프로토콜로 전환될 수 있어야 한다. Google 엔지니어는 측정한 실패 비율이 낮은 한 자릿수라고 얘기했다.

\(DNS에 사용되는\) 53 포트가 아닌 포트의 UDP 트래픽을 차단하는 기업용 및 기타 네트워크 설정이 있다. 또 다른 설정은 여러 방법으로 이러한 데이터를 제한하기 때문에 QUIC은 TCP에 기반을 둔 프로토콜보다 성능이 더 좋지 않다. 이 때문에, 몇몇 운영자가 해야 할 일에는 끝이 없다.

### 동작할 것인가?

현재 알려진 모든 QUIC 구현체는 사용자 영역에 있으므로 커널 영역의 구현체보다 훨씬 빠른 발전이 가능하다.

UDP에 기반을 둔 QUIC은 UDP 포트 번호를 사용해서 주어진 IP 주소의 특정 네트워크 서비스를 식별한다.

QUIC은 UDP 위에 구현한 전송 프로토콜이다. 우리가 임의로 네트워크 트래픽을 보면 QUIC이 UDP 패킷으로 나타나는 것을 볼 것이다.

### 신뢰할 수 있는 데이터 전송

한 엔드포인트로부터 QUIC을 통해 전송된 데이터는 연결이 유지되는 한 다른 엔드포인트에서 수신할 수 있다.

UDP가 데이터 전송의 신뢰성을 보장하지 않지만, QUIC은 UDP 위에 새로운 계층을 추가함으로써 신뢰성을 제공한다. 추가된 계층은 TCP에 존재하는 패킷 재전송, 혼잡 제어, 속도 조정 및 다른 기능들을 제공한다.

### 연결 내의 다중 스트림

더 자세한 내용은 [연결](https://github.com/bagder/http3-explained/blob/master/ko/quic-connections.md)과 [스트림](https://github.com/bagder/http3-explained/blob/master/ko/quic-streams.md) 부분을 참고하라.

QUIC은 연결과 스트림 모두에서 흐름 제어를 제공한다.

만들어진 연결을 통해 양쪽에서 스트림을 만들어 다른 쪽으로 데이터를 보낼 수 있다. 스트림은 순서대로 전달되고 신뢰할 수 있지만 서로 다른 스트림은 순서 없이 전달될 수 있다.

두 엔드포인트 사이에 연결 협상이 이뤄지는 방식은 TCP 연결이 동작하는 방식과 비슷하다. QUIC 연결은 UDP 포트와 IP 주소로 이루어져 있지만 일단 연결을 만들고 나면 "connection ID"로 연결된다.

QUIC은 SCTP, SSH, HTTP/2와 마찬가지로 물리 연결 내에서 논리적 스트림을 나눌 수 있다. 하나의 연결로 다수의 병렬 스트림으로 다른 스트림에 영향을 주지 않고 데이터를 동시에 전송할 수 있다.

### 순서에 맞는 전송

QUIC은 스트림의 순서 있는 전송을 보장하지만 스트림 사이에서는 \(순서를\) 보장하지 않는다. 스트림은 순서대로 데이터를 전송하고 유지하지만, 각 스트림은 애플리케이션이 보낸 것과는 다른 순서대로 목적지에 도착할 수 있다!

스트림 A와 B가 서버에서 클라이언트로 이동하는 예를 생각해 보자. 스트림 A를 먼저 시작하고 이어서 스트림 B를 시작했다. QUIC에서 잃어버린 패킷은 해당 패킷이 속한 스트림에만 영향을 준다. 스트림 A는 패킷을 잃어버렸지만 스트림 B는 잃어버리지 않았다면 스트림 A의 잃어버린 패킷을 다시 전송하는 동안 스트림 B는 계속해서 전송하면서 완료될 수 있다. 이는 HTTP/2에서는 불가능했다.

다음은 하나의 연결을 통해 두 QUIC 앤드포인트 사이에 보내진 노란색 스트림과 파란색 스트림의 그림이다. 이 두 스트림은 독립적이고 다른 순서로 도착할 것이지만 각 스트림은 신뢰할 수 있게 애플리케이션에 순서대로 전달된다.

[![&#xB450; &#xCEF4;&#xD4E8;&#xD130; &#xC0AC;&#xC774;&#xC5D0; &#xB450; QUIC &#xC2A4;&#xD2B8;&#xB9BC;](https://github.com/bagder/http3-explained/raw/master/images/quic-chain-streams.png)](https://github.com/bagder/http3-explained/blob/master/images/quic-chain-streams.png)

### 빠른 핸드쉐이크 

QUIC은 클라이언트가 이미 0-RTT 핸드쉐이크에 데이터를 넣을 수 있다. 이 기능으로 데이터를 피어에 최대한 빨리 전달할 수 있으므로 서버가 더 빨리 응답하고 데이터를 돌려줄 수 있다.

### 초기 데이터

QUIC은 0-RTT와 1-RTT 연결 설정을 둘 다 지원한다. 즉, 최선의 상황에서는 새로운 연결을 설정할 때 추가적인 라운드 트립이 전혀 필요치 않는다. 둘 중 가장 빠른 0-RTT 핸드쉐이크는 호스트에 이미 이전 연결이 구성되어 있고 해당 연결의 시크릿이 캐시 되어 있을 때만 동작한다.



### TLS 1.3

QUIC에서 사용하는 전송 보안은 TLS 1.3\([RFC 8446](https://tools.ietf.org/html/rfc8446)\)이며 암호화하지 않은 QUIC 연결은 절대로 존재하지 않는다.

이전 버전의 TLS와 비교해서 TLS 1.3에 몇몇 장점이 있지만 QUIC이 TLS 1.3을 사용한 주된 이유는 핸드쉐이크에 더 적은 라운드 트립이 필요하도록 바뀌었기 때문이다. 이는 프로토콜 지연을 줄여준다.

QUIC의 Google 레거시 버전은 커스텀 암호화를 사용했다.



### 전송 계층과 애플리케이션 계층

IETF QUIC 프로토콜은 전송 프로토콜로써 다른 애플리케이션 프로토콜이 그 위에서 사용할 수 있다. 첫 애플리케이션 계층 프로토콜은 HTTP/3\(h3\)다.

전송 계층은 연결과 스트림을 지원한다.

레거시 Google 버전 QUIC은 전송과 HTTP가 하나로 합쳐져 있어서 \(IETF QUIC\) 보다 더 특수한 목적의 send-http/2-frames-over-udp 프로토콜이었다.



### QUIC을 통한 HTTP/3

HTTP/3라고 부르는 HTTP 계층은 HTTP 형태의 전송을 한다. 그 중에는 HPACK이라 부르는 HTTP/2 헤더 압축과 비슷한 QPACK을 사용한 HTTP 헤더 압축도 있다.

HPACK 알고리즘은 _순차적인_ 스트림 전달에 의존하는데 QUIC은 스트림을 순서 없이 전달할 수 있으므로 HPACK을 수정하지 않고는 HTTP/3에서 재사용할 수 없다. [HPACK](https://httpwg.org/specs/rfc7541.html)을 QUIC에 맞게 수정한 것을 QPACK이라 볼 수 있다.



### QUIC을 통한 HTTP가 아닌 프로토콜

QUIC을 통해 HTTP가 아닌 프로토콜을 보내는 작업은 QUIC 버전 1 출시 이후로 연기되었다.



  


## 

  



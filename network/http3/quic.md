# 왜 QUIC인가

## 왜 QUIC인가

QUIC은 약어가 아니라 이름이다. 영어단어 "quick"과 똑같이 발음한다.

QUIC은 많은 부분에서 HTTP 같은 프로토콜에 적합하다. TCP와 TLS에서 동작하는 HTTP/2의 단점으로 알려진 문제를 해결하면서 안정적이고 안전한 새 전송 프로토콜로 볼 수 있다.

QUIC은 HTTP 전송에만 국한되지 않는다. 최종 사용자에게 웹과 데이터를 더 빨리 전달하려는 바람이 초기 이 새로운 전송 프로토콜을 만들게 된 가장 큰 이유이자 원동력이다.

그러면 새로운 전송 프로토콜은 왜 만들고 왜 UDP 상에서 동작하게 했는가?

[![QUIC &#xB85C;&#xACE0;](https://github.com/bagder/http3-explained/raw/master/images/QUIC.png)](https://github.com/bagder/http3-explained/blob/master/images/QUIC.png)

### HTTP/2를 기억하는가?

HTTP/2 명세인 [RFC 7540](https://httpwg.org/specs/rfc7540.html)는 2015년 5월에 발행되었고 이후 인터넷과 월드 와이드 웹에 널리 구현되고 배포되었다.

2018년 초 상위 1,000개의 웹사이트 중 거의 40%가 HTTP/2로 동작하고 있으며 Firefox가 보낸 모든 HTTPS 요청의 70% 정도가 HTTP/2 응답을 받았고 주요 모든 브라우저와 서버, 프락시가 이를 지원하고 있다.

HTTP/2는 HTTP/1의 수많은 결점을 수정했고 HTTP의 두 번째 버전을 도입함으로써 사용자들이 수많은 우회법을 사용하지 않게 되었다. 그 중 일부는 웹 개발자에게 상당한 부담이었다.

HTTP/2의 주요 기능 중 하나인 멀티플렉싱을 사용하여 같은 물리 TCP 연결을 통해 다수의 논리 스트림을 보낼 수 있게 된 것이다. 이는 많은 것을 더 좋고 빠르게 만들었다. 또한, 혼잡 제어 작업을 훨씬 낫게 해주어 사용자가 TCP를 훨씬 잘 사용하게 되면서 대역폭을 적절하게 가득 채워서 사용해 TCP 연결을 더 오래 유지되도록 만들었다. 이는 이전보다 더 자주 최대 속도를 낼 수 있기 때문에 좋아진 것이다. 헤더 압축은 대역폭을 적게 사용하게끔 해준다.

이전에는 브라우저가 호스트당 _6개의_ TCP 연결을 사용했지만, HTTP/2를 사용하면 보통 _하나의_ TCP 연결을 사용한다. 사실 HTTP/2에서 연결 병합과 "desharding" 기술을 사용하면 연결 수를 훨씬 더 줄일 수도 있다.

HTTP/2는 클라이언트가 다음 요청을 보내기 전에 첫 요청이 끝나기를 기다려야 하는 HTTP HOL\(head of line\) 블로킹 문제를 고쳤다



### TCP HOL\(head of line\) 블로킹

HTTP/2는 TCP를 사용하며 이전 HTTP 버전을 사용할 때 보다 더 적은 TCP 연결을 사용한다. TCP는 신뢰할 수 있는 전송 프로토콜이고 기본적으로 두 머신 간의 가상 체인으로 생각해도 된다. 네트워크의 한쪽 끝에 넣은 것이 최종적으로 다른 쪽 끝에 같은 순서로 나올 것이다.\(아니면 연결이 끊어진다.\)

[![&#xB450; &#xCEF4;&#xD4E8;&#xD130; &#xC0AC;&#xC774;&#xC758; TCP &#xCCB4;&#xC778;](https://github.com/bagder/http3-explained/raw/master/images/tcp-chain.png)](https://github.com/bagder/http3-explained/blob/master/images/tcp-chain.png)

HTTP/2를 사용하는 일반적인 브라우저는 TCP 연결 한개로 수십, 수백 개의 병렬 전송을 한다.

#### HTTP/2로 통신하는 두 엔드포인트 사이 네트워크 어딘가에서 하나의 패킷이 빠지거나 없어진다면 없어진 패킷을 다시 전송하고 목적지를 찾는 동안 전체 TCP 연결이 중단되게 된다. 즉, TCP는 "체인"이기 때문에 한 링크가 갑자기 사라지면 그 링크 이후에 와야 하는 모든 것들이 기다려야 한다는 뜻이다.

체인 메타포를 사용해서 이 연결을 통해 두 스트림을 보내는 경우를 그린 그림을 보자. 빨간색 스트림과 녹색 스트림이 있다.

[![&#xCCB4;&#xC778;&#xC5D0;&#xC11C; &#xB9C1;&#xD06C;&#xB294; &#xB2E4;&#xB978; &#xC0C9;&#xC73C;&#xB85C; &#xBCF4;&#xC5EC;&#xC900;&#xB2E4;](https://github.com/bagder/http3-explained/raw/master/images/tcp-chain-streams.png)](https://github.com/bagder/http3-explained/blob/master/images/tcp-chain-streams.png)

이는 TCP에 기반을 둔 head of line 블로킹이 된다!

패킷 손실률이 증가하면 HTTP/2의 성능도 저하된다. 테스트를 통해 패킷 손실률이 2%\(상기하자면, 이는 끔찍한 네트워크 품질이다\) 일때 HTTP/1 사용자가 더 나은 것으로 입증했다. 그 이유는 HTTP/1은 보통 손실된 패킷을 분배하는데 6개의 TCP 연결을 갖고 있어서 손실된 패킷이 없는 다른 연결은 계속 사용할 수 있기 때문이다.

TCP를 사용하는 한 이 이슈를 고치는 것은 \(가능할 수도 있지만\) 쉽지 않다.

### 차단을 피하는 독립 스트림

QUIC에는 두 엔드포인트간에 연결을 안전하게 하고 데이터 전달을 신뢰할 수 있게 하는 연결 설정이 있다.

[![&#xB450; &#xCEF4;&#xD4E8;&#xD130; &#xC0AC;&#xC774;&#xC758; QUIC &#xCCB4;&#xC778;](https://github.com/bagder/http3-explained/raw/master/images/tcp-chain.png)](https://github.com/bagder/http3-explained/blob/master/images/tcp-chain.png)

이 연결을 통해 두 가지 다른 스트림을 설정했을 때 이들을 독립적으로 다루므로 스트림 중 하나에서 어떤 링크가 사라지더라도 해당 스트림만\(특정 체인\) 멈추고 재전송될 없어진 링크를 기다란다.

다음은 두 엔드포인트간에 노란색과 파란색 스트림을 보내는 그림이다.

[![&#xB450; &#xCEF4;&#xD4E8;&#xD130; &#xC0AC;&#xC774;&#xC758; &#xB450; &#xAC00;&#xC9C0; QUIC &#xC2A4;&#xD2B8;&#xB9BC;](https://github.com/bagder/http3-explained/raw/master/images/quic-chain-streams.png)](https://github.com/bagder/http3-explained/blob/master/images/quic-chain-streams.png)

### TCP 혹은 UDP

TCP에서 head-of-line 블로킹을 해결할 수 없다면 이론적으로 네트워크 스택에서 UDP와 TCP 옆에 새로운 전송 프로토콜을 만들 수 있다. 아니면 [RFC 4960](https://tools.ietf.org/html/rfc4960)에서 IETF가 표준화하고 여러 가지 원하는 특성이 있는 전송 프로토콜인 [SCTP](https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol)를 사용할 수도 있다.

하지만, 최근 수년간 새로운 전송 프로토콜을 만들려는 노력은 인터넷에서 그것을 배포하는 어려움 때문에 완전히 멈춰 있다. 새 프로토콜 배포는 그 프로토콜이 도달해야 하는 사용자와 서버 사이에 있는 TCP와 UDP만 허용하는 방화벽, NAT, 라우터 등의 미들박스에 의해 방해받고 있다. 다른 전송 프로토콜의 도입은 UDP 또는 TCP 가 아닌 경우 이를 악의적이거나 뭔가 잘못되었다고 판단하고 차단해 버리는 박스들에 의해 차단되므로 연결의 N%가 실패한다. 노력을 기울이기에 N% 실패율은 너무 높다고 여겨진다.

게다가 보통 네트워크 스택의 전송 프로토콜 계층에서 뭔가를 바꾼다는 것은 보통 운영체제 커널에서 구현한 프로토콜을 말한다. 새로운 운영체제 커널을 갱신하고 배포하는 것은 상당한 노력이 필요한 느린 과정이다. IETF가 표준화한 수많은 TCP 개선사항도 광범위하게 지원되지 않아서 널리 배포되거나 사용되지 않고 있다.

### 왜 SCTP-over-UDP가 아닌가

SCTP는 스트림을 가진 신뢰성 있는 전송 프로토콜이고 WebRTC처럼 UDP 위에서 이 프로토콜을 사용하는 기존의 구현체도 있다.

다음의 몇 가지 이유로 QUIC의 대체재로 충분하지 않다고 생각했다.

* SCTP는 스트림에 대해 head-of-line 블로킹 문제를 고치지 못한다
* SCTP는 연결을 설정할 때 스트림의 수를 결정해야 한다
* SCTP에는 견고한 TLS/보안에 대한 언급이 없다
* SCTP는 4단계 핸드쉐이크\(4-way handshake\)를 사용하고 QUIC은 0-RTT를 제공한다
* QUIC는 TCP 같은 바이트스트림\(bytestream\)이고 SCTP는 메시지 기반이다
* QUIC 연결은 IP 주소 사이에서 마이그레이션을 할 수 있지만 SCTP는 할 수 없다

자세한 차이점이 알고 싶다면 [A Comparison between SCTP and QUIC](https://tools.ietf.org/html/draft-joseph-quic-comparison-quic-sctp-00)을 참고하라.

## 고착화\(Ossification\)

인터넷은 네트워크의 네트워크다. 이 네트워크의 네트워크가 의도대로 동작하게 하는 장비가 인터넷 여러 곳에 설치되어 있다. 우리는 이러한 기기\(네트워크에 분포된 박스\)를 미들박스라고 부른다. 이 박스는 전통적인 네트워크 데이터 전송의 주요 요소인 두 엔드포인트 사이에 있다.

박스는 여러 가지 다른 목적이 있지만 무언가 동작하게 하려면 이 박스가 해당 위치에 있어야 한다고 누군가 생각했기 때문에 곳곳에 깔린 것이라 생각한다.

미들박스는 네트워크 사이에서 IP 패킷을 라우팅하고, 악성 트래픽을 차단하고, NAT\(Network Address Translation\) 역할을 하고, 성능을 향상시키고, 통과하는 트래픽을 감시하는 등의 역할을 한다.

이러한 박스는 의무를 다하려면 자신들이 모니터링하고 수정하는 네트워크 및 프로토콜에 대해 반드시 알아야 한다. 박스는 이런 목적으로 소프트웨어를 실행한다. 그 소프트웨어를 항상 자주 업그레이드하는 것은 아니다.

박스는 인터넷이 유지되도록 연결하는 구성 요소이지만 종종 최신 기술을 따라잡지 못하는 경우가 있다. 보통 네트워크 중간 영역은 전 세계의 클라이언트나 서버 같은 엣지 만큼 빠르게 바뀌지 않는다.

어떤 프로토콜을 검사하기를 원하는지, 그리고 어떤것이 괜찮고 안 괜찮은지 알고있는 박스들은 과거에 배포되었고 그 당시의 프로토콜 기능 셋을 가지고 있다. 이전에는 몰랐던 새로운 기능이나 동작의 변경 사항이 추가되면 박스가 이를 잘못된 것이나 허용하지 않는 것으로 판단할 위험이 있다. 그래서 이러한 트래픽은 사용자가 해당 기능을 사용하고 싶지 않을 정도로 지연되거나 중단될 수 있다.

이를 "프로토콜 고착화\(ossification\)"라고 부른다.

TCP를 변경하는 것도 고착화 문제를 겪는다. 클라이언트와 원격 서버 사이에 있는 박스 중 일부는 알지 못하는 새로운 TCP 옵션을 발견하고 이 옵션이 무엇인지 몰라서 해당 연결을 차단해버릴 것이다. 프로토콜의 상세 내용을 탐지하도록 허용한 경우 시스템은 프로토콜이 보통 어떻게 동작하는지 배우게 되고 시간이 지나면 프로토콜을 변경할 수 없게 된다.

유일하게 고착화를 "방지하는데" 효과적인 방법은 미들박스가 지나가는 프로토콜에서 많은 것을 볼 수 없도록 통신을 최대한 암호화하는 것이다.

### 안전

QUIC은 항상 안전하다. 이 프로토콜에는 일반 텍스트 버전이 없으므로 QUIC 연결과 협상하려면 TLS 1.3을 사용해서 암호화 및 보안을 수행해야 한다. 위에서 언급했다시피, 이는 다른 차단이나 특별한 처리 같은 고착화 문제를 방지할 뿐만 아니라 QUIC이 웹 사용자가 기대하고 원하는 HTTPS의 모든 보안 속성을 가지게 만든다.

암호화 프로토콜 협상이 이뤄지기 전 초기 핸드쉐이크 패킷에 일반 텍스트 메시지가 아주 조금 있다.

## 더 이른 데이터

QUIC는 0-RTT, 1-RTT 핸드쉐이크 둘 다 제공하는데 이는 새로운 연결을 협상하고 설정하는데 걸리는 시간을 줄여준다. TCP의 3단계 핸드쉐이크\(3-way handshake\)와 비교해 보면 된다.

여기에 추가로 QUIC은 더 많은 데이터를 허용하는 "이른 데이터\(early data\)"를 처음부터 지원하고 이는 TCP Fast Open보다 더 쉽게 사용할 수 있다.

스트림 개념을 사용해서 기존에 존재하는 연결이 끝나기를 먼저 기다릴 필요 없이 같은 호스트로의 또 다른 논리 연결도 동시에 처리될 수 있다.

### 문제가 있는 TCP Fast Open

TCP Fast Open는 2014년 12월 [RFC 7413](https://tools.ietf.org/html/rfc7413)로 발행되었고 이 명세는 이미 전달된 첫 번째 TCP SYN 패킷에 서버로 보낼 데이터를 전달하는 방법을 설명한다.

현실에서 이 기능의 실제 지원은 시간이 걸렸고 2018년인 오늘날까지도 문제로 가득하다. TCP 스택을 구현하는 사람이 문제를 이미 겪었으므로 애플리케이션이 이 기능의 이점을 취하려고 시도했다. 이를 활성화하기 위해 OS 버전이 무엇인지 알아야 할 뿐만 아니라 문제가 발생하면 그레이스풀하게 철회하고 문제를 다루는 방법을 찾아내야 한다. 여러 네트워크가 TFO 트래픽을 방해하는 것으로 밝혀졌고 이러한 TCP 핸드쉐이크를 적극적으로 망쳤다.





